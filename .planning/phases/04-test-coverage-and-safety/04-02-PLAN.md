---
phase: 04-test-coverage-and-safety
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/camtparser/concurrent_processor_test.go
  - internal/camtparser/concurrent_processor.go
autonomous: true

must_haves:
  truths:
    - "Concurrent processing handles context cancellation without data loss"
    - "Race conditions are tested under concurrent load"
    - "Partial results are handled correctly when context cancels mid-processing"
  artifacts:
    - path: "internal/camtparser/concurrent_processor_test.go"
      provides: "Context cancellation tests"
      contains: "TestConcurrentProcessor.*Cancellation"
      min_lines: 50
    - path: "internal/camtparser/concurrent_processor_test.go"
      provides: "Race condition tests"
      contains: "TestConcurrentProcessor.*Race"
      min_lines: 40
  key_links:
    - from: "concurrent_processor_test.go"
      to: "context.WithCancel"
      via: "cancellation test setup"
      pattern: "ctx.*cancel.*context\\.WithCancel"
    - from: "concurrent_processor.go"
      to: "ctx.Done()"
      via: "cancellation handling"
      pattern: "ctx\\.Done\\(\\)"
---

<objective>
Add comprehensive edge case tests for concurrent transaction processing, covering race conditions, context cancellation mid-processing, and partial result handling to ensure data integrity under failure scenarios.

Purpose: Close TEST-02 requirement by validating concurrent processing robustness and proper cleanup.
Output: Concurrent processor tests covering cancellation, races, and partial results.
</objective>

<execution_context>
@/Users/fjacquet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fjacquet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/codebase/CONCERNS.md

Current test coverage: concurrent_processor_test.go tests happy path (small/large file processing) but doesn't cover:
- Context cancellation mid-processing
- Race conditions under concurrent load
- Partial result handling when workers are still running

Risk: Data loss or corruption under high concurrency or cancellation scenarios.
</context>

<tasks>

<task type="auto">
  <name>Add context cancellation tests</name>
  <files>internal/camtparser/concurrent_processor_test.go</files>
  <action>
Add test cases for context cancellation scenarios:

1. **TestConcurrentProcessor_CancellationBeforeStart** - Cancel context before calling ProcessTransactions, verify graceful handling
2. **TestConcurrentProcessor_CancellationDuringProcessing** - Create 500 entries, start processing, cancel context after 100ms, verify:
   - No panic occurs
   - Some results may be returned (workers already started)
   - No data corruption in returned transactions
   - No goroutine leaks (use defer to check goroutine count)
3. **TestConcurrentProcessor_CancellationWaitsForInflightWork** - Verify workers complete current items before stopping

Use `context.WithCancel()` and `time.AfterFunc()` to trigger cancellation mid-processing.
Check for goroutine leaks by comparing `runtime.NumGoroutine()` before/after with cleanup delay.
  </action>
  <verify>Run `go test -v ./internal/camtparser -run Cancellation` to verify all cancellation tests pass</verify>
  <done>Context cancellation tests verify graceful shutdown without panics, data corruption, or goroutine leaks</done>
</task>

<task type="auto">
  <name>Add race condition tests</name>
  <files>internal/camtparser/concurrent_processor_test.go</files>
  <action>
Add test cases for race condition detection:

1. **TestConcurrentProcessor_NoRaceConditions** - Process 1000 entries concurrently with a processor function that:
   - Uses atomic counters to track invocations
   - Sleeps randomly (0-5ms) to increase race probability
   - Verifies final counter matches entry count
2. **TestConcurrentProcessor_ResultChannelNoRaceOnClose** - Verify result channel is closed correctly without races
3. Add a test that runs with `-race` flag enabled (document this in verify step)

Use `sync/atomic` package for safe counter increments.
Add `testing.Short()` guard so race tests can be skipped in short mode.
  </action>
  <verify>Run `go test -race -v ./internal/camtparser -run Race` to verify no race conditions detected</verify>
  <done>Race condition tests pass with -race flag, verifying thread-safe concurrent processing</done>
</task>

<task type="auto">
  <name>Add partial result handling tests</name>
  <files>internal/camtparser/concurrent_processor_test.go</files>
  <action>
Add test case for partial result handling:

**TestConcurrentProcessor_PartialResults** - Test scenario where some workers complete before cancellation:
- Create 200 entries
- Start processing with slow processor (10ms per entry)
- Cancel context after 50ms (some workers will have completed)
- Verify:
  - Returned slice contains only valid transactions (no partial/corrupt data)
  - Result count is less than input count (some dropped due to cancellation)
  - Each returned transaction has valid fields (non-zero amount, valid date)

This tests the "partial results are OK" behavior when context is cancelled.
  </action>
  <verify>Run `go test -v ./internal/camtparser -run PartialResults` to verify partial result handling works correctly</verify>
  <done>Partial result test verifies clean handling of incomplete processing with valid returned data</done>
</task>

</tasks>

<verification>
1. All concurrent processor tests pass: `go test -v ./internal/camtparser`
2. No race conditions detected: `go test -race ./internal/camtparser`
3. No goroutine leaks in cancellation tests
4. Tests cover all three edge cases: cancellation, races, partial results
</verification>

<success_criteria>
- Context cancellation tests verify graceful shutdown without panics or leaks
- Race detector finds no issues when running with -race flag
- Partial result tests verify data integrity under cancellation
- Test coverage includes edge cases not previously tested
</success_criteria>

<output>
After completion, create `.planning/phases/04-test-coverage-and-safety/04-02-SUMMARY.md`
</output>
