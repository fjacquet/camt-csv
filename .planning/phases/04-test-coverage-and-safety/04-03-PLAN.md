---
phase: 04-test-coverage-and-safety
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/pdfparser/pdfparser_test.go
  - internal/pdfparser/pdfparser_helpers.go
  - internal/camtparser/camtparser_test.go
  - internal/debitparser/debitparser_test.go
  - internal/revolutparser/revolutparser_test.go
  - internal/selmaparser/selmaparser_test.go
autonomous: true

must_haves:
  truths:
    - "PDF format detection handles edge cases without misidentifying formats"
    - "Error messages include file path and field context across all parsers"
    - "Users can diagnose parsing failures from error messages alone"
  artifacts:
    - path: "internal/pdfparser/pdfparser_test.go"
      provides: "Viseca format edge case tests"
      contains: "TestVisecaFormatDetection.*EdgeCases"
      min_lines: 80
    - path: "internal/pdfparser/pdfparser_test.go"
      provides: "Error message validation tests"
      contains: "TestErrorMessages.*Context"
    - path: "internal/camtparser/camtparser_test.go"
      provides: "CAMT error context validation"
      contains: "filepath.*error"
  key_links:
    - from: "pdfparser_test.go"
      to: "pdfparser_helpers.go:isVisecaFormat"
      via: "format detection test"
      pattern: "isVisecaFormat.*true|false"
    - from: "error message tests"
      to: "fmt.Errorf.*%w"
      via: "error wrapping verification"
      pattern: "errors\\.Is|errors\\.As"
---

<objective>
Add comprehensive tests for PDF format detection edge cases and validate error message quality across all parsers, ensuring users receive clear diagnostic information when parsing fails.

Purpose: Close TEST-03 and TEST-04 requirements by validating format detection robustness and error message clarity.
Output: Edge case tests for PDF format detection and error message validation across all parsers.
</objective>

<execution_context>
@/Users/fjacquet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fjacquet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/codebase/CONCERNS.md

PDF format detection logic (pdfparser_helpers.go lines 133-164):
- Checks for Viseca column headers: "Datum Buchung Beschreibung Betrag"
- Checks for Viseca card pattern: regex match
- Checks for statement features

Edge cases not tested:
- Partial Viseca markers (some but not all patterns present)
- Viseca-like text in transaction descriptions
- Ambiguous formats that could match multiple patterns

Error message issue (CONCERNS.md): "Most functions return fmt.Errorf(...%w...) but tests don't verify error chain depth or message clarity. Users see generic 'error parsing' without context about which file or field failed."
</context>

<tasks>

<task type="auto">
  <name>Add PDF format detection edge case tests</name>
  <files>internal/pdfparser/pdfparser_test.go</files>
  <action>
Add comprehensive tests for Viseca format detection edge cases:

1. **TestVisecaFormatDetection_PartialMarkers** - Test files with:
   - Only column header match (no card pattern or statement features) - should still detect as Viseca
   - Only card pattern (no headers) - should still detect as Viseca
   - No markers at all - should detect as standard format

2. **TestVisecaFormatDetection_FalsePositives** - Test files where:
   - Transaction description contains "Datum Buchung Beschreibung" text - should NOT falsely trigger Viseca format
   - Cardholder name contains Viseca-like patterns - verify correct behavior

3. **TestVisecaFormatDetection_AmbiguousFormats** - Test files with:
   - Mixed format indicators (both Viseca and standard markers)
   - Very short files with limited data
   - Files with only headers but no transactions

Create test helper function `createTestPDFText(visecaMarkers, standardMarkers, transactionCount)` to generate test inputs programmatically.

Document the decision logic: "Viseca detection requires at least ONE of three markers. If detected, use Viseca parser. Otherwise use standard parser."
  </action>
  <verify>Run `go test -v ./internal/pdfparser -run VisecaFormatDetection` to verify all edge cases are handled correctly</verify>
  <done>PDF format detection tests cover partial markers, false positives, and ambiguous formats with clear expected behavior</done>
</task>

<task type="auto">
  <name>Add error message validation tests for PDF parser</name>
  <files>internal/pdfparser/pdfparser_test.go</files>
  <action>
Add tests to validate error message quality:

**TestPDFParser_ErrorMessagesIncludeContext** - Test that parsing errors include:
- File path in error message (verify with errors.Is or string contains)
- Field name when field parsing fails (e.g., "error parsing amount in transaction 5")
- Line number or transaction index for debugging
- Actionable guidance when possible

Test scenarios:
1. Invalid PDF file path - error should include the attempted path
2. Malformed transaction data - error should include transaction index and field name
3. pdftotext command failure - error should mention pdftotext and suggest installation

Use `assert.ErrorContains(t, err, "transaction 5")` or similar to verify context inclusion.
  </action>
  <verify>Run `go test -v ./internal/pdfparser -run ErrorMessages` to verify error messages include context</verify>
  <done>PDF parser error messages include file path, transaction index, field name, and actionable guidance</done>
</task>

<task type="auto">
  <name>Add error message validation tests for other parsers</name>
  <files>
internal/camtparser/camtparser_test.go
internal/debitparser/debitparser_test.go
internal/revolutparser/revolutparser_test.go
internal/selmaparser/selmaparser_test.go
  </files>
  <action>
For each parser (CAMT, Debit, Revolut, Selma), add a test case that validates error message quality:

**TestXXXParser_ErrorMessagesIncludeFilePath** - For each parser:
1. Create test case with invalid input (malformed XML, invalid CSV, missing required fields)
2. Call Parse() or ParseWithExtractor() with the invalid input
3. Verify error message contains:
   - File path or input identifier
   - Specific field or element that failed
   - Error cause (not just "parsing failed")

Example assertion pattern:
```go
err := parser.Parse(ctx, invalidInput)
require.Error(t, err)
assert.Contains(t, err.Error(), "test_file.xml")
assert.Contains(t, err.Error(), "Amount") // field name
```

Add helper function `assertErrorHasContext(t, err, filepath, fieldName)` to reduce duplication across test files.
  </action>
  <verify>Run `go test -v ./internal/camtparser ./internal/debitparser ./internal/revolutparser ./internal/selmaparser -run ErrorMessages` to verify all parsers include context in errors</verify>
  <done>All parsers include file path and field context in error messages, enabling users to diagnose failures</done>
</task>

</tasks>

<verification>
1. All parser tests pass: `make test`
2. PDF format detection tests cover edge cases (partial markers, false positives, ambiguous formats)
3. Error message tests verify context inclusion (file path, field name, transaction index)
4. Error messages are actionable and help users diagnose issues
</verification>

<success_criteria>
- PDF format detection handles all identified edge cases without misidentification
- Every parser has error message validation test
- Error messages include enough context for user to fix issue (file, field, cause)
- Tests document expected behavior for ambiguous cases
</success_criteria>

<output>
After completion, create `.planning/phases/04-test-coverage-and-safety/04-03-SUMMARY.md`
</output>
