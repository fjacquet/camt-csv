---
phase: 04-test-coverage-and-safety
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/store/store.go
  - internal/store/store_test.go
  - internal/config/viper.go
autonomous: true

must_haves:
  truths:
    - "Category YAML files are backed up before any auto-learn overwrite"
    - "Backup location is configurable via config file"
    - "Failed saves do not corrupt existing YAML files"
  artifacts:
    - path: "internal/store/store.go"
      provides: "Backup creation before save"
      contains: "createBackup|BackupFile"
      exports: ["createBackup"]
    - path: "internal/store/store_test.go"
      provides: "Backup functionality tests"
      contains: "TestCategoryStore.*Backup"
      min_lines: 60
    - path: "internal/config/viper.go"
      provides: "Backup configuration settings"
      contains: "backup_dir|backup.enabled"
  key_links:
    - from: "store.SaveCreditorMappings"
      to: "store.createBackup"
      via: "backup before save"
      pattern: "createBackup.*before.*WriteFile"
    - from: "store.SaveDebtorMappings"
      to: "store.createBackup"
      via: "backup before save"
      pattern: "createBackup.*before.*WriteFile"
---

<objective>
Implement automatic backup of category YAML files before auto-learning overwrites them, with configurable backup location and timestamped filenames to prevent data loss from incorrect AI categorizations.

Purpose: Close SAFE-01 requirement by providing safety net for category mapping changes.
Output: Backup functionality integrated into store save operations with configuration support.
</objective>

<execution_context>
@/Users/fjacquet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fjacquet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/codebase/CONCERNS.md

Current issue (CONCERNS.md): "YAML files are overwritten without backup. If auto-learned category is wrong, user must manually fix YAML (no undo)."

Store implementation (store.go lines 238-290):
- SaveCreditorMappings writes directly to file (line 285)
- SaveDebtorMappings writes directly to file (similar pattern)
- No backup mechanism exists

Configuration system: Viper-based config in internal/config/viper.go supports hierarchical configuration with defaults.
</context>

<tasks>

<task type="auto">
  <name>Add backup configuration to Viper config</name>
  <files>internal/config/viper.go</files>
  <action>
Add backup-related configuration keys to Viper config:

1. Add default values in SetDefaults():
   - `backup.enabled` (bool, default: true)
   - `backup.directory` (string, default: "" which means same directory as original file)
   - `backup.timestamp_format` (string, default: "20060102_150405")

2. Document configuration keys in config file comments or documentation

3. Add getter methods if needed:
   - `GetBackupEnabled() bool`
   - `GetBackupDirectory() string`
   - `GetBackupTimestampFormat() string`

The backup file pattern will be: `{original_name}.{timestamp}.backup`
Example: `creditors.yaml.20260201_143022.backup`
  </action>
  <verify>Run `go test -v ./internal/config` to verify config changes don't break existing tests</verify>
  <done>Viper config supports backup.enabled, backup.directory, and backup.timestamp_format settings</done>
</task>

<task type="auto">
  <name>Implement backup functionality in CategoryStore</name>
  <files>internal/store/store.go</files>
  <action>
Add backup functionality to CategoryStore:

1. Add private method `createBackup(filePath string) error`:
   - Check if file exists (skip backup if not)
   - Read backup configuration from global config (or accept as parameter)
   - Skip backup if backup.enabled is false
   - Generate timestamped backup filename: `{original}.{timestamp}.backup`
   - Determine backup location (backup.directory if set, else same dir as original)
   - Copy original file to backup location
   - Return error if backup fails (critical - don't proceed with save if backup fails)

2. Update SaveCreditorMappings:
   - Call createBackup(filePath) BEFORE marshaling and writing
   - Only write new file if backup succeeds
   - Wrap errors to indicate "failed to backup" vs "failed to save"

3. Update SaveDebtorMappings:
   - Same pattern as SaveCreditorMappings

Error handling: If backup fails, SaveXXXMappings should return error WITHOUT writing new file. This prevents data loss if backup directory is not writable.

Security note: Backup files should use same permissions as originals (0644 for category mappings per SEC-03).
  </action>
  <verify>Run `go test -v ./internal/store` to verify backup functionality doesn't break existing save operations</verify>
  <done>CategoryStore creates timestamped backups before saving, with configurable location and format</done>
</task>

<task type="auto">
  <name>Add comprehensive backup tests</name>
  <files>internal/store/store_test.go</files>
  <action>
Add test cases for backup functionality:

1. **TestCategoryStore_BackupCreatedBeforeSave** - Verify backup is created:
   - Create initial creditors.yaml file
   - Save new mappings
   - Verify backup file exists with timestamp pattern
   - Verify backup contains original data
   - Verify new file contains updated data

2. **TestCategoryStore_BackupUsesConfiguredLocation** - Verify backup.directory config:
   - Set backup.directory to custom path
   - Save mappings
   - Verify backup is in custom directory, not same directory as original

3. **TestCategoryStore_BackupFailurePreventsSave** - Verify atomic behavior:
   - Create read-only backup directory
   - Attempt to save mappings
   - Verify save returns error
   - Verify original file is unchanged (backup failure prevented save)

4. **TestCategoryStore_BackupDisabledSkipsBackup** - Verify backup.enabled config:
   - Set backup.enabled = false
   - Save mappings
   - Verify no backup file created
   - Verify save still works

5. **TestCategoryStore_MultipleBackupsWithTimestamps** - Verify multiple backups:
   - Save mappings multiple times with small delay
   - Verify multiple backup files exist with different timestamps
   - Verify each backup preserves data from that point in time

Use t.TempDir() for test file locations. Mock or override config values in tests.
  </action>
  <verify>Run `go test -v ./internal/store -run Backup` to verify all backup scenarios work correctly</verify>
  <done>Backup functionality is thoroughly tested covering success, failure, and configuration scenarios</done>
</task>

</tasks>

<verification>
1. All store tests pass: `go test -v ./internal/store`
2. Backup files are created before saves with correct timestamps
3. Configuration controls backup behavior (enabled, directory, format)
4. Backup failure prevents save (no data loss)
5. Backup files have correct permissions (0644)
</verification>

<success_criteria>
- Category YAML files are backed up before every auto-learn save
- Backup location is configurable (default: same directory)
- Backup filenames include timestamps (e.g., creditors.yaml.20260201_143022.backup)
- Failed backups prevent save (atomic behavior)
- Users can recover from incorrect AI categorizations by restoring backups
</success_criteria>

<output>
After completion, create `.planning/phases/04-test-coverage-and-safety/04-04-SUMMARY.md`
</output>
