---
phase: 01-critical-bugs-and-security
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/categorizer/gemini_client.go
  - internal/pdfparser/pdfparser_helpers.go
  - internal/pdfparser/pdfparser.go
  - internal/store/store.go
autonomous: true

must_haves:
  truths:
    - "API credentials never appear in any log output at any level"
    - "All temporary files use random unpredictable names"
    - "File permissions are appropriate for content type (0644 for non-secrets, 0600 for credentials)"
  artifacts:
    - path: "internal/categorizer/gemini_client.go"
      provides: "API categorization without credential leakage"
      not_contains: "apiKey.*Debug\\|apiKey.*Info"
    - path: "internal/pdfparser/pdfparser_helpers.go"
      provides: "Secure temp file creation"
      contains: "os.CreateTemp"
      not_contains: "pdfFile.*\\.txt"
  key_links:
    - from: "extractTextFromPDFImpl"
      to: "temp file creation"
      via: "os.CreateTemp with random naming"
      pattern: "os\\.CreateTemp.*\\.txt"
    - from: "file permissions"
      to: "content type"
      via: "0644 for non-secrets, 0600 for credentials"
      pattern: "0644\\|0600"
---

<objective>
Harden security by ensuring API credentials never leak through logs, temporary files use random unpredictable names, and file permissions match content sensitivity.

Purpose: Prevent credential leakage, temp file race conditions, and permission-related security vulnerabilities.

Output: Security-hardened codebase with no credential logging, randomized temp files, and appropriate file permissions.
</objective>

<execution_context>
@/Users/fjacquet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fjacquet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/fjacquet/Projects/camt-csv/.planning/PROJECT.md
@/Users/fjacquet/Projects/camt-csv/.planning/ROADMAP.md
@/Users/fjacquet/Projects/camt-csv/.planning/STATE.md
@/Users/fjacquet/Projects/camt-csv/CLAUDE.md
@/Users/fjacquet/Projects/camt-csv/.planning/codebase/CONCERNS.md
@/Users/fjacquet/Projects/camt-csv/internal/categorizer/gemini_client.go
@/Users/fjacquet/Projects/camt-csv/internal/pdfparser/pdfparser_helpers.go
</context>

<tasks>

<task type="auto">
  <name>Audit and ensure no API credential logging</name>
  <files>internal/categorizer/gemini_client.go</files>
  <action>
Audit all logging statements in gemini_client.go to ensure the apiKey field is never logged at any level.

Current code at line 97 is acceptable:
```go
c.log.Debug("No API key available, skipping AI categorization")
```
This logs presence/absence without the key value.

Review lines 105-109, 131-134 to confirm no apiKey is included:
- Line 105-109: Logs party_name and description (OK - no apiKey)
- Line 131-134: Logs party_name and category (OK - no apiKey)

Add a code comment at the top of the file documenting this security requirement:
```go
// Security note: The apiKey field must NEVER be logged at any level.
// Only log presence/absence of the key, never its value.
```

Grep the entire codebase for any potential apiKey logging:
```bash
grep -r "apiKey\|GEMINI_API_KEY" internal/ --include="*.go" | grep -i "log\|debug\|info\|warn"
```

If any matches are found that log the actual key value (not just presence/absence), remove or redact them.

Rationale: API credentials in logs can leak through log aggregation systems, shared logs, or debug output. Even debug-level logging is a risk because debug mode might be enabled in production for troubleshooting.
  </action>
  <verify>
Run: `grep -n "apiKey" internal/categorizer/gemini_client.go`
Expected: No lines that log the apiKey value, only comments and presence checks

Run: `grep -r "GEMINI_API_KEY.*log\|log.*GEMINI_API_KEY" internal/`
Expected: No matches (key value never logged)

Run: `make test`
Expected: All tests pass
  </verify>
  <done>
- Security comment added to gemini_client.go documenting no-credential-logging policy
- All logging statements audited and confirmed to never log apiKey value
- Only presence/absence of API key is logged, never the value
- No credential leakage in any log output
  </done>
</task>

<task type="auto">
  <name>Use random temp file naming in PDF text extraction</name>
  <files>internal/pdfparser/pdfparser_helpers.go</files>
  <action>
Replace the predictable temp file naming at line 86 with os.CreateTemp for random naming.

Current problematic code:
```go
func extractTextFromPDFImpl(pdfFile string) (string, error) {
    // Create a temporary file to store the text output
    tempFile := pdfFile + ".txt"  // ‚Üê PREDICTABLE NAME

    cmd := exec.Command("pdftotext", "-layout", "-raw", pdfFile, tempFile)
    err := cmd.Run()
    if err != nil {
        return "", fmt.Errorf("error running pdftotext: %w", err)
    }

    output, err := os.ReadFile(tempFile)
    if err != nil {
        return "", fmt.Errorf("error reading extracted text: %w", err)
    }

    if err := os.Remove(tempFile); err != nil {
        getDefaultLogger().WithError(err).Warn("Failed to remove temporary file")
    }

    return string(output), nil
}
```

Replace with:
```go
func extractTextFromPDFImpl(pdfFile string) (string, error) {
    // Create a temporary file with random name for text output
    tempFile, err := os.CreateTemp("", "pdftext-*.txt")
    if err != nil {
        return "", fmt.Errorf("failed to create temp file: %w", err)
    }
    tempPath := tempFile.Name()
    tempFile.Close() // Close before pdftotext writes to it

    defer func() {
        if err := os.Remove(tempPath); err != nil {
            getDefaultLogger().WithError(err).Warn("Failed to remove temporary file",
                logging.Field{Key: "file", Value: tempPath})
        }
    }()

    cmd := exec.Command("pdftotext", "-layout", "-raw", pdfFile, tempPath)
    err = cmd.Run()
    if err != nil {
        return "", fmt.Errorf("error running pdftotext: %w", err)
    }

    output, err := os.ReadFile(tempPath)
    if err != nil {
        return "", fmt.Errorf("error reading extracted text: %w", err)
    }

    return string(output), nil
}
```

Rationale: Predictable temp file names in shared directories (like /tmp) can enable race conditions or temp file hijacking attacks. os.CreateTemp generates random names that are unpredictable.
  </action>
  <verify>
Run: `grep -n "pdfFile.*\\.txt" internal/pdfparser/pdfparser_helpers.go`
Expected: No matches (predictable naming removed)

Run: `grep -n "os.CreateTemp.*pdftext" internal/pdfparser/pdfparser_helpers.go`
Expected: Match found (random temp file creation)

Run: `make test`
Expected: All tests pass with random temp file naming
  </verify>
  <done>
- extractTextFromPDFImpl uses os.CreateTemp for random temp file names
- No predictable temp file patterns (pdfFile + ".txt") remain
- Temp files properly cleaned up with defer
- Tests pass with secure temp file handling
  </done>
</task>

<task type="auto">
  <name>Audit and standardize file permissions</name>
  <files>internal/pdfparser/pdfparser.go, internal/store/store.go</files>
  <action>
Audit all os.WriteFile and os.OpenFile calls to ensure file permissions match content sensitivity:
- Use 0644 (rw-r--r--) for non-secret files: CSV output, debug output, non-sensitive data
- Use 0600 (rw-------) for files containing credentials or sensitive data

Find all file permission usage:
```bash
grep -n "0600\|0644\|WriteFile\|OpenFile" internal/ --include="*.go"
```

Expected changes:
1. internal/pdfparser/pdfparser.go line 97 (if debug file is restored in the future): Use 0644 for debug output (non-secret)
2. internal/store/store.go: Review YAML file permissions - these contain category mappings (non-secret), should be 0644

In store.go, find WriteToFile functions and update permissions:
```go
// Before (if using 0600):
err := os.WriteFile(filePath, data, 0600)

// After (for non-secret category mappings):
err := os.WriteFile(filePath, data, 0644)
```

Add comment documenting permission rationale:
```go
// Use 0644 for category mappings - non-secret data that may be shared
```

If any files contain credentials (API keys, tokens), those should remain 0600. Based on the codebase review, category YAML files do not contain credentials.

Rationale: Overly restrictive permissions (0600) on non-secret files can cause issues in shared environments. Conversely, permissive permissions on secrets are a security risk. Match permissions to content sensitivity.
  </action>
  <verify>
Run: `grep -n "WriteFile.*0600" internal/store/store.go`
Expected: No matches for non-secret YAML files (should be 0644)

Run: `grep -n "WriteFile.*0644" internal/store/store.go`
Expected: Matches for category YAML file writes

Run: `make test`
Expected: All tests pass, files created with appropriate permissions

Test file permissions:
```bash
make test && find . -name "*.yaml" -type f -exec stat -f "%A %N" {} \; | grep -v ".git"
```
Expected: YAML files have 644 permissions (non-secret data)
  </verify>
  <done>
- All file permissions audited across codebase
- Non-secret files (CSV, YAML category mappings) use 0644
- Secret files (if any) use 0600
- Comments document permission rationale
- Tests verify correct permissions
  </done>
</task>

</tasks>

<verification>
Run security audit commands:

Check for credential logging:
```bash
grep -r "apiKey\|GEMINI_API_KEY" internal/ --include="*.go" | grep -i "log"
```
Expected: Only presence/absence logging, no key values

Check for predictable temp files:
```bash
grep -r "pdfFile.*\\.txt\|tempFile.*=.*+.*\\.txt" internal/ --include="*.go"
```
Expected: No matches (all use os.CreateTemp)

Check file permissions:
```bash
grep -n "0600\|0644" internal/ --include="*.go"
```
Expected: 0644 for non-secrets, 0600 for secrets only

Run full test suite:
```bash
make test
```
Expected: All tests pass
</verification>

<success_criteria>
1. API key value never appears in any log output at any level
2. Only presence/absence of API key is logged
3. All temporary files created with os.CreateTemp (random unpredictable names)
4. File permissions match content sensitivity (0644 non-secrets, 0600 secrets)
5. Security comments document credential and permission policies
6. Full test suite passes with security hardening in place
</success_criteria>

<output>
After completion, create `.planning/phases/01-critical-bugs-and-security/01-03-SUMMARY.md`
</output>
