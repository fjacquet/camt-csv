---
phase: 03-architecture-and-error-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .planning/codebase/CONVENTIONS.md
autonomous: true

must_haves:
  truths:
    - "Error handling patterns are documented with clear guidance"
    - "Patterns distinguish between exit, retry, and continue scenarios"
    - "Examples show how to apply patterns in command handlers"
  artifacts:
    - path: ".planning/codebase/CONVENTIONS.md"
      provides: "Error handling patterns section"
      contains: "## Error Handling Patterns"
      min_lines: 50
  key_links:
    - from: ".planning/codebase/CONVENTIONS.md"
      to: "cmd/*"
      via: "documented pattern implementation"
      pattern: "log\\.Fatal|return.*error"
---

<objective>
Define and document error handling patterns for consistent, predictable error behavior across all CLI commands.

Purpose: Establish clear guidelines for when to exit immediately, when to retry, and when to continue with degraded functionality. This creates a foundation for consistent error handling that eliminates unpredictable behavior.

Output: Updated CONVENTIONS.md with comprehensive error handling patterns section that all command implementations will follow.
</objective>

<execution_context>
@/Users/fjacquet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fjacquet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONCERNS.md
</context>

<tasks>

<task type="auto">
  <name>Define error handling hierarchy</name>
  <files>.planning/codebase/CONVENTIONS.md</files>
  <action>
Add a new "## Error Handling Patterns" section to CONVENTIONS.md that defines three error severity levels:

1. **Fatal errors (exit immediately)**: Configuration failures, missing required flags, container initialization failures, file permission errors that block core functionality
2. **Retryable errors (log and retry)**: Network errors (AI API), temporary file system issues, rate limiting
3. **Recoverable errors (log and continue)**: Single transaction parsing failures, optional categorization failures, non-critical file cleanup failures

For each level, specify:
- When to use it
- What log level to use (Fatal, Error, Warn)
- Whether to exit immediately or continue
- How to format error messages (include file path, field context)

Include the error handling approach from ARCHITECTURE.md lines 184-204 (custom error types with wrapping) and explain how they integrate with severity levels.
  </action>
  <verify>grep -A 30 "## Error Handling Patterns" .planning/codebase/CONVENTIONS.md</verify>
  <done>CONVENTIONS.md contains "Error Handling Patterns" section with three severity levels defined, each with clear usage criteria</done>
</task>

<task type="auto">
  <name>Document pattern implementation examples</name>
  <files>.planning/codebase/CONVENTIONS.md</files>
  <action>
Add concrete code examples to the Error Handling Patterns section showing:

**Fatal error example (exit immediately):**
```go
if appContainer == nil {
    log.Fatal("Container not initialized - check configuration")
}
```

**Retryable error example (future: retry logic):**
```go
// Currently: log and continue
if err := categorizer.Categorize(ctx, tx); err != nil {
    logger.WithError(err).Warn("Failed to categorize transaction",
        logging.Field{Key: "party", Value: tx.PartyName})
    // Continue with uncategorized transaction
}
```

**Recoverable error example (log and continue):**
```go
if err := tempFile.Close(); err != nil {
    logger.WithError(err).Warn("Failed to close temporary file",
        logging.Field{Key: "file", Value: tempFile.Name()})
}
// Continue - cleanup failure is non-critical
```

Include guidance on init() function error handling:
- AVOID: `panic(err)` in init() - causes immediate crash with poor error message
- PREFER: Log error in command Run function where context is available
- For MarkFlagRequired errors: Accept that Cobra will handle the error gracefully

Reference existing patterns from:
- cmd/common/process.go (proper error wrapping with context)
- internal/pdfparser/pdfparser.go lines 44-52 (cleanup error logging)
  </action>
  <verify>grep -B 5 -A 10 "Fatal error example" .planning/codebase/CONVENTIONS.md</verify>
  <done>CONVENTIONS.md contains 3+ code examples showing fatal, retryable, and recoverable error patterns with clear "AVOID/PREFER" guidance</done>
</task>

</tasks>

<verification>
1. Read .planning/codebase/CONVENTIONS.md and confirm "Error Handling Patterns" section exists
2. Verify section defines three severity levels with usage criteria
3. Verify section contains at least 3 code examples with AVOID/PREFER guidance
4. Verify section addresses init() function error handling specifically
</verification>

<success_criteria>
- CONVENTIONS.md updated with comprehensive error handling patterns
- Three severity levels documented: fatal, retryable, recoverable
- Code examples provided for each pattern
- Guidance on init() function error handling included
- Ready for command implementations in Plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/03-architecture-and-error-handling/03-01-SUMMARY.md`
</output>
