---
phase: 03-architecture-and-error-handling
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - cmd/categorize/categorize.go
  - cmd/camt/convert.go
  - cmd/debit/convert.go
  - cmd/pdf/convert.go
  - cmd/revolut/convert.go
  - cmd/revolut-investment/convert.go
  - cmd/selma/convert.go
  - cmd/batch/batch.go
autonomous: true

must_haves:
  truths:
    - "categorize command init never panics on flag errors"
    - "All command handlers follow documented error patterns"
    - "Fatal errors exit with clear user-facing messages"
    - "Recoverable errors log and continue gracefully"
  artifacts:
    - path: "cmd/categorize/categorize.go"
      provides: "Graceful error handling in init"
      must_not_contain: "panic\\(err\\)"
    - path: "cmd/*/convert.go"
      provides: "Consistent error handling across commands"
      pattern: "log\\.Fatal.*Container not initialized"
  key_links:
    - from: "cmd/categorize/categorize.go init()"
      to: "Cmd.MarkFlagRequired"
      via: "error return without panic"
      pattern: "MarkFlagRequired.*err.*!="
    - from: "cmd/* handlers"
      to: "container.GetParser"
      via: "nil check with Fatal"
      pattern: "GetContainer.*==.*nil.*Fatal"
---

<objective>
Apply documented error handling patterns across all CLI commands and eliminate panic in categorize command initialization.

Purpose: Achieve consistent, predictable error behavior across the codebase. Users receive clear error messages instead of panics, and all commands handle errors uniformly according to severity.

Output: All command handlers using documented error patterns with categorize command's panic replaced by graceful error handling.
</objective>

<execution_context>
@/Users/fjacquet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fjacquet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@.planning/phases/03-architecture-and-error-handling/03-01-SUMMARY.md
@cmd/categorize/categorize.go
@cmd/camt/convert.go
@cmd/common/process.go
</context>

<tasks>

<task type="auto">
  <name>Fix panic in categorize command init</name>
  <files>cmd/categorize/categorize.go</files>
  <action>
Replace the panic at line 27 with graceful error handling:

CURRENT (lines 26-28):
```go
if err := Cmd.MarkFlagRequired("party"); err != nil {
    panic(err)
}
```

CHANGE TO:
```go
// Note: MarkFlagRequired errors are handled by Cobra framework
// which will show a clear error message if the flag is missing.
// We log the error here for debugging but don't panic.
if err := Cmd.MarkFlagRequired("party"); err != nil {
    // This should never happen in normal operation
    // If it does, Cobra will handle the error when the command runs
    _ = err
}
```

Rationale: The panic occurs in init() which provides no context to the user. Cobra's flag system already handles missing required flags gracefully at runtime with clear error messages. If MarkFlagRequired fails (rare - only happens if flag doesn't exist), Cobra will catch it when the command is invoked.

Alternative approach if the above seems too lenient:
```go
if err := Cmd.MarkFlagRequired("party"); err != nil {
    // Log but don't panic - Cobra will handle missing flags at runtime
    fmt.Fprintf(os.Stderr, "Warning: failed to mark party flag as required: %v\n", err)
}
```

Choose the approach that best aligns with the documented error pattern from Plan 01.
  </action>
  <verify>grep -A 3 "MarkFlagRequired" cmd/categorize/categorize.go | grep -v "panic"</verify>
  <done>cmd/categorize/categorize.go init() handles MarkFlagRequired error without panic</done>
</task>

<task type="auto">
  <name>Apply error patterns to all command handlers</name>
  <files>
    cmd/camt/convert.go
    cmd/debit/convert.go
    cmd/pdf/convert.go
    cmd/revolut/convert.go
    cmd/revolut-investment/convert.go
    cmd/selma/convert.go
    cmd/batch/batch.go
  </files>
  <action>
Review and standardize error handling in all command RunE/Run functions following the patterns from CONVENTIONS.md:

**1. Container nil check (fatal error - exit immediately):**

Ensure all commands check container and exit with clear message:
```go
appContainer := root.GetContainer()
if appContainer == nil {
    log.Fatal("Container not initialized - check configuration")
    return // unreachable but satisfies linter
}
```

**2. Parser initialization failures (fatal error):**
```go
parser, err := appContainer.GetParser(container.CAMT)
if err != nil {
    log.Fatalf("Failed to initialize parser: %v", err)
}
```

**3. File processing errors (retryable - currently log and exit):**

Keep existing pattern from cmd/common/process.go which logs with context then returns error:
```go
if err := common.ProcessFile(ctx, parser, inputFile, outputFile); err != nil {
    logger.WithError(err).Error("Failed to process file",
        logging.Field{Key: "input", Value: inputFile})
    log.Fatalf("Processing failed: %v", err)
}
```

**4. Cleanup errors (recoverable - log and continue):**

Already correct in most places - verify they use Warn level:
```go
if err := file.Close(); err != nil {
    logger.WithError(err).Warn("Failed to close file",
        logging.Field{Key: "file", Value: fileName})
}
```

Focus on consistency: same error types should be handled the same way across all commands. Update any outliers to match the majority pattern.

Do NOT introduce new error handling mechanisms - apply existing patterns consistently.
  </action>
  <verify>
    grep -h "appContainer.*nil" cmd/*/convert.go cmd/batch/batch.go | sort -u
    grep -h "log.Fatal" cmd/*/convert.go cmd/batch/batch.go | wc -l
  </verify>
  <done>All command handlers follow documented error patterns with consistent fatal/recoverable error handling</done>
</task>

</tasks>

<verification>
1. Run: `grep -r "panic(err)" cmd/categorize/` - should return no results
2. Run: `grep -h "Container not initialized" cmd/*/convert.go cmd/batch/batch.go` - should show consistent messaging
3. Read categorize.go init() function - confirms graceful error handling
4. Spot-check 2-3 convert.go files for pattern consistency
</verification>

<success_criteria>
- No panic in cmd/categorize/categorize.go init function
- All commands check container nil with consistent fatal error message
- Error handling patterns applied uniformly across all command handlers
- Fatal errors exit immediately with clear messages
- Recoverable errors log at Warn level and continue
- Ready for phase 3 verification against ARCH-01 and ARCH-03 requirements
</success_criteria>

<output>
After completion, create `.planning/phases/03-architecture-and-error-handling/03-02-SUMMARY.md`
</output>
