---
phase: 03-architecture-and-error-handling
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - cmd/categorize/categorize.go
  - cmd/camt/convert.go
  - cmd/debit/convert.go
  - cmd/pdf/convert.go
  - cmd/revolut/convert.go
  - cmd/revolut-investment/convert.go
  - cmd/selma/convert.go
  - cmd/batch/batch.go
autonomous: true

must_haves:
  truths:
    - "categorize command init never panics on flag errors"
    - "All command handlers follow documented error patterns"
    - "Fatal errors exit with clear user-facing messages"
    - "Recoverable errors log and continue gracefully"
  artifacts:
    - path: "cmd/categorize/categorize.go"
      provides: "Graceful error handling in init"
      must_not_contain: "panic\\(err\\)"
    - path: "cmd/*/convert.go"
      provides: "Consistent error handling across commands"
      pattern: "log\\.Fatal.*Container not initialized"
  key_links:
    - from: "cmd/categorize/categorize.go init()"
      to: "Cmd.MarkFlagRequired"
      via: "error return without panic"
      pattern: "MarkFlagRequired.*err.*!="
    - from: "cmd/* handlers"
      to: "container.GetParser"
      via: "nil check with Fatal"
      pattern: "GetContainer.*==.*nil.*Fatal"
---

<objective>
Apply documented error handling patterns across all CLI commands and eliminate panic in categorize command initialization.

Purpose: Achieve consistent, predictable error behavior across the codebase. Users receive clear error messages instead of panics, and all commands handle errors uniformly according to severity.

Output: All command handlers using documented error patterns with categorize command's panic replaced by graceful error handling.
</objective>

<execution_context>
@/Users/fjacquet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fjacquet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@.planning/phases/03-architecture-and-error-handling/03-01-SUMMARY.md
@cmd/categorize/categorize.go
@cmd/camt/convert.go
@cmd/common/process.go
</context>

<tasks>

<task type="auto">
  <name>Fix panic in categorize command init</name>
  <files>cmd/categorize/categorize.go</files>
  <action>
Replace the panic at line 27 with graceful error handling:

CURRENT (lines 26-28):
```go
if err := Cmd.MarkFlagRequired("party"); err != nil {
    panic(err)
}
```

CHANGE TO:
```go
// Note: MarkFlagRequired errors are handled by Cobra framework
// which will show a clear error message if the flag is missing.
// We log the error here for debugging but don't panic.
if err := Cmd.MarkFlagRequired("party"); err != nil {
    // This should never happen in normal operation
    // If it does, Cobra will handle the error when the command runs
    _ = err
}
```

Rationale: The panic occurs in init() which provides no context to the user. Cobra's flag system already handles missing required flags gracefully at runtime with clear error messages. If MarkFlagRequired fails (rare - only happens if flag doesn't exist), Cobra will catch it when the command is invoked.

Alternative approach if the above seems too lenient:
```go
if err := Cmd.MarkFlagRequired("party"); err != nil {
    // Log but don't panic - Cobra will handle missing flags at runtime
    fmt.Fprintf(os.Stderr, "Warning: failed to mark party flag as required: %v\n", err)
}
```

Choose the approach that best aligns with the documented error pattern from Plan 01.
  </action>
  <verify>grep -A 3 "MarkFlagRequired" cmd/categorize/categorize.go | grep -v "panic"</verify>
  <done>cmd/categorize/categorize.go init() handles MarkFlagRequired error without panic</done>
</task>

<task type="auto">
  <name>Audit command error handling and fix inconsistencies</name>
  <files>
    cmd/camt/convert.go
    cmd/debit/convert.go
    cmd/pdf/convert.go
    cmd/revolut/convert.go
    cmd/revolut-investment/convert.go
    cmd/selma/convert.go
    cmd/batch/batch.go
  </files>
  <action>
Audit all command handlers for consistency with documented error patterns. Only modify code that actually deviates from the established pattern.

**Audit checklist:**

1. **Container nil check pattern** - verify all commands have:
```go
appContainer := root.GetContainer()
if appContainer == nil {
    log.Fatal("Container not initialized - check configuration")
}
```

2. **Parser initialization pattern** - verify:
```go
parser, err := appContainer.GetParser(container.ParserType)
if err != nil {
    log.Fatalf("Failed to initialize parser: %v", err)
}
```

3. **File processing errors** - verify they follow cmd/common/process.go pattern:
```go
if err := common.ProcessFile(ctx, parser, inputFile, outputFile); err != nil {
    logger.WithError(err).Error("Failed to process file", ...)
    log.Fatalf("Processing failed: %v", err)
}
```

4. **Cleanup errors** - verify they use Warn level and continue:
```go
if err := file.Close(); err != nil {
    logger.WithError(err).Warn("Failed to close file", ...)
}
```

**Process:**
1. READ each command file first to understand current state
2. IDENTIFY actual deviations from the documented patterns (not just style differences)
3. FIX only the deviations that impact consistency (e.g., different error messages for same error type, wrong log level)
4. DOCUMENT in task output which files were modified and why

**Do NOT:**
- Change code that already follows the pattern (even if worded differently)
- Introduce new error handling mechanisms
- Modify working error flows unless they're genuinely inconsistent
- Make cosmetic changes

If all commands already follow the pattern consistently, document that fact and make NO changes.
  </action>
  <verify>
    grep -h "Container not initialized" cmd/*/convert.go cmd/batch/batch.go | wc -l
    grep -h "appContainer.*==.*nil" cmd/*/convert.go cmd/batch/batch.go | wc -l
  </verify>
  <done>Command error handling audited; actual inconsistencies fixed (or confirmed all consistent)</done>
</task>

</tasks>

<verification>
1. Run: `grep -r "panic(err)" cmd/categorize/` - should return no results
2. Run: `grep -h "Container not initialized" cmd/*/convert.go cmd/batch/batch.go` - should show consistent messaging
3. Read categorize.go init() function - confirms graceful error handling
4. Spot-check 2-3 convert.go files for pattern consistency
</verification>

<success_criteria>
- No panic in cmd/categorize/categorize.go init function
- All commands check container nil with consistent fatal error message
- Error handling patterns applied uniformly across all command handlers
- Fatal errors exit immediately with clear messages
- Recoverable errors log at Warn level and continue
- Ready for phase 3 verification against ARCH-01 and ARCH-03 requirements
</success_criteria>

<output>
After completion, create `.planning/phases/03-architecture-and-error-handling/03-02-SUMMARY.md`
</output>
